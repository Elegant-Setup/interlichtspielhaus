package vbw;

import java.awt.BasicStroke;
import java.awt.Color;
import java.awt.Font;
import java.awt.Graphics;
import java.awt.Graphics2D;
import java.awt.GridLayout;
import java.awt.Point;
import java.awt.Polygon;
import java.awt.Rectangle;
import java.awt.RenderingHints;
import java.awt.event.MouseAdapter;
import java.awt.event.MouseEvent;
import java.awt.geom.Ellipse2D;
import java.text.SimpleDateFormat;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collections;
import java.util.Comparator;
import java.util.Date;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Random;

import javax.swing.JApplet;
import javax.swing.JFrame;
import javax.swing.JPanel;
import javax.swing.SwingUtilities;

/*

 Study of Mondrian's Victory Boogie Woogie
 -----------------------------------------
 author : INTERLICHTSPIELHAUS
 site : http://www.interlichtspielhaus.org/vbw/VictoryBoogieWoogie.html
 mail : interlichtspielhaus@gmail.com

09-03-2013-015733.intrah

 there is the undefined infinite background
 the losange in front as some kind of window
 or maybe a magnifying glass
 , and in between those spaces an attempt of the following

 a first structure is built of 8 verticals and 8 horizontals
 the intersections of these lines define a grid

 the grid is made up of blocks ( manhattanlingo )
 , these 9 by 9 blocks define the division of further drawing

 these blocks don't know of each other's existence
 , they're just neighbors
 or selfstaring cells

 the widest and highest of these rows and columns are each split in 2
 , to further granularize the grid

 each of these blocks
 , whether directly originating from the grid
 or derived from it through through the above splitting
 has a relation to the losange
 , it has none, one, two, three or four corners within it

 this amount of corners within the losange determines for each block
 the amount of recursive cycles that it will undergo

 during a cycle of recursion of a block
 , derived blocks are created
 which will in turn also be recursed

 the different actions potentially performed on a block during a recursive cycle are:
 - split the block horizontally or vertically
 - shift blocks horizontally or vertically
 - creating a strip of small blocks within and/or outside the boundaries of the block being recursed
 - change the surface color of the block
 - draw a rectangle in the middle of the block
 - delete a derived block

 these actions are the most visible ones in Mondrian's Victory Boogie Woogie
 , things are continuously being shifted, split, rearranged, recolored, overwritten, extended ..
 always repeating and never repeating itself

 if at the end of one recurse cycle the block has no derived blocks created
 then the block is looped through the cycle again
 , crossing fingers

 at the moment of creation each block receives a shuffled version of the string "MONDRIAN"
 , this shuffled string is used within the recursion to see if a certain action should be performed or not
 letters are removed and sometimes added

 at the end of all recursions the blocks are drawn
 and the strings of all blocks are written left and right of the blocks

 a lot of drawn elements remain invisible
 , lost in between the layers of overlapping blocks
 victory buggy wuggy ?

 */
public class VictoryBoogieWoogie extends JApplet {
	private static final long serialVersionUID = 1L;
	private VBWPanel panel;

	@Override
	public void init() {
		initComponents();
	}

	private void initComponents() {
		setLayout(new GridLayout(1, 1));
		setSize(DrawingMachine.CANVAS_WIDTH, DrawingMachine.CANVAS_HEIGHT);
		this.panel = new VBWPanel();
		getContentPane().add(this.panel);

	}

	public VBWPanel getPanel() {
		return this.panel;
	}

	public static void main(String[] args) {
		JFrame.setDefaultLookAndFeelDecorated(true);

		SwingUtilities.invokeLater(new Runnable() {
			@Override
			public void run() {
				VBWCanvas canvas = new VBWCanvas();
				canvas.setLayout(new GridLayout(1, 1));
				canvas.setSize(1300, 1000);

				final VBWPanel vbw = new VBWPanel();
				canvas.getContentPane().add(vbw);

				canvas.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
				canvas.setVisible(true);
			}
		});
	}
}

class VBWCanvas extends JFrame {
	private static final long serialVersionUID = 1L;

	public VBWCanvas() {
		super();
	}
}

class Mondrian {
	public static final String MONDRIAN = "MONDRIAN";
	public static final String M = "M";
	public static final String O = "O";
	public static final String N = "N";
	public static final String D = "D";
	public static final String R = "R";
	public static final String I = "I";
	public static final String A = "A";

	// public static final String N = "N";
	public static String getRandomMondrianLetter() {
		return RandomEngine.getRandomLetterFromString(MONDRIAN);
	}
}

enum Direction {
	HORIZONTAL, VERTICAL;
}

class RandomEngine {
	private static final Random random;
	static {
		random = new Random();
	}

	public static boolean getBoolean() {
		return random.nextBoolean();
	}

	public static int getPositiveInt(int positive) {
		return random.nextInt(Math.abs(positive));
	}

	public static int getNaturalInt(int number) {
		int ret = getPositiveInt(number);
		if (getBoolean()) {
			return -ret;
		} else {
			return ret;
		}
	}

	public static boolean getBooleanInt(int positive) {
		return 0 == getPositiveInt(positive);
	}

	public static String shuffleString(String text) {
		List<String> toShuffle = Arrays.asList(text.split(""));
		Collections.shuffle(toShuffle);
		String shuffledString = "";
		for (String letter : toShuffle) {
			shuffledString += letter;
		}
		return shuffledString;
	}

	public static String getRandomLetterFromString(String text) {
		return String.valueOf(text.charAt(getPositiveInt(text.length())));
	}
}

class ColorEngine {
	private static List<Color> primaryColors;
	private static List<Color> greys;
	private static List<Color> victoryColors;
	private static List<Color> victoryColorsWithoutGrey;
	private static List<Color> extendedPrimaryColors;

	private static final int COLOR_VARIATION = 28;

	private static final int RGB_LOW_LIMIT = 0;
	private static final int RGB_HIGH_LIMIT = 255;

	public static final Color PRINTCOLOR;

	static {
		primaryColors = new ArrayList<Color>();
		primaryColors.add(Color.YELLOW);
		primaryColors.add(Color.RED);
		primaryColors.add(Color.BLUE);

		extendedPrimaryColors = new ArrayList<Color>();
		extendedPrimaryColors.addAll(primaryColors);
		extendedPrimaryColors.add(Color.WHITE);
		extendedPrimaryColors.add(Color.BLACK);

		greys = new ArrayList<Color>();
		greys.add(new Color(187, 187, 187));
		greys.add(new Color(199, 199, 199));
		greys.add(new Color(210, 210, 210));
		greys.add(new Color(218, 218, 218));
		greys.add(new Color(226, 226, 226));
		greys.add(new Color(232, 232, 232));

		victoryColors = new ArrayList<Color>();
		victoryColors.addAll(primaryColors);
		victoryColors.addAll(primaryColors);
		// victoryColors.addAll(primaryColors);
		victoryColors.addAll(greys);
		victoryColors.addAll(greys);
		victoryColors.add(Color.WHITE);
		victoryColors.add(Color.WHITE);
		victoryColors.add(Color.WHITE);
		victoryColors.add(Color.BLACK);
		victoryColors.add(Color.BLACK);

		victoryColorsWithoutGrey = new ArrayList<Color>();
		victoryColorsWithoutGrey.addAll(primaryColors);
		victoryColorsWithoutGrey.add(Color.WHITE);
		victoryColorsWithoutGrey.add(Color.BLACK);

		PRINTCOLOR = new Color(230, 230, 230);
	}

	public ColorEngine() {

	}

	private static int getRandomIntVariation() {
		return RandomEngine.getPositiveInt(COLOR_VARIATION);
	}

	private static int getColorVariationOn(int rgb) {
		int colorVariation = getRandomIntVariation() + 1;
		if (rgb + colorVariation > RGB_HIGH_LIMIT) {
			rgb -= colorVariation;
		} else if (rgb - colorVariation < RGB_LOW_LIMIT) {
			rgb += colorVariation;
		} else if (RandomEngine.getBoolean()) {
			rgb += colorVariation;
		} else {
			rgb -= colorVariation;
		}

		return rgb;
	}

	public static Color getFromWhiteToBlack() {
		int rgb = RandomEngine.getPositiveInt(RGB_HIGH_LIMIT) + 1;
		return new Color(rgb, rgb, rgb);
	}

	public static Color getVictoryColorWithoutGrey(boolean variation) {
		Color victoryColor = victoryColorsWithoutGrey.get(RandomEngine.getPositiveInt(victoryColorsWithoutGrey.size()));
		Color toReturn = new Color(victoryColor.getRed(), victoryColor.getGreen(), victoryColor.getBlue());
		if (variation) {
			toReturn = addLittleColorVariation(toReturn);
		}
		return toReturn;
	}

	public static Color getExtendedPrimaryColors(boolean variation) {
		Color victoryColor = extendedPrimaryColors.get(RandomEngine.getPositiveInt(extendedPrimaryColors.size()));
		Color toReturn = new Color(victoryColor.getRed(), victoryColor.getGreen(), victoryColor.getBlue());
		if (variation) {
			toReturn = addLittleColorVariation(toReturn);
		}
		return toReturn;
	}

	public static Color getVictoryColor(boolean variation) {
		Color victoryColor = victoryColors.get(RandomEngine.getPositiveInt(victoryColors.size()));
		Color toReturn = new Color(victoryColor.getRed(), victoryColor.getGreen(), victoryColor.getBlue());
		if (variation) {
			toReturn = addLittleColorVariation(toReturn);
		}
		return toReturn;
	}

	public static Color addLittleColorVariation(Color color) {
		int r = getColorVariationOn(color.getRed());
		int g = getColorVariationOn(color.getGreen());
		int b = getColorVariationOn(color.getBlue());

		return new Color(r, g, b);
	}

	public static Color getPrimaryColor(boolean variation) {
		Color primaryColor = primaryColors.get(RandomEngine.getPositiveInt(primaryColors.size()));
		Color toReturn = new Color(primaryColor.getRed(), primaryColor.getGreen(), primaryColor.getBlue());
		if (variation) {
			toReturn = addLittleColorVariation(toReturn);
		}
		return toReturn;
	}

	public static Color getRandomGrey() {
		int from = 220;
		int rgb = from - RandomEngine.getPositiveInt(30);
		return new Color(rgb, rgb, rgb);
	}

	public static Color getVariatedWhite() {
		int rgb = 255;
		int whiteVariation = 34;
		return new Color(rgb - RandomEngine.getPositiveInt(whiteVariation), rgb - RandomEngine.getPositiveInt(whiteVariation), rgb
				- RandomEngine.getPositiveInt(whiteVariation));
	}
}

enum RelationToLosangeForRecursion {
	/*
	 * each of these blocks , whether directly originating from the grid or
	 * derived from it through through the above splitting has a relation to the
	 * losange , it has none, one, two, three or four corners within it
	 * 
	 * this amount of corners within the losange determines for each block the
	 * amount of recursive cycles that it will undergo
	 */
	COMPLETELY_INSIDE(4), THREE_POINTS_INSIDE(3), TWO_POINTS_INSIDE(2), ONE_POINT_INSIDE(1), NONE(0);
	private int recursionIndex;

	private RelationToLosangeForRecursion(int recursionIndex) {
		this.recursionIndex = recursionIndex;
	}

	public int getRecursionIndex() {
		return recursionIndex;
	}
}

class DivisionBlock implements Comparable<DivisionBlock> {
	private double distanceToCenter;
	private RelationToLosangeForRecursion relationToLosangeForRecursion;
	private Point northWest;
	private Point northEast;
	private Point southWest;
	private Point southEast;
	private Integer xIndex;
	private Integer yIndex;
	private Color groundColor;
	// this divisionBlock is created from a point where 2 colored lines
	// intersect
	// the following 2 colors are those historicals
	private Color initialHorizontalColor;
	private Color initialVerticalColor;
	private List<DivisionBlock> derivedDivisions;

	private Integer levelOfRecursion;
	private String mondrian;

	private ManhattanBuilder manhattanRecurser;

	public DivisionBlock(int northWestX, int northWestY, int southEastX, int southEastY, int xIndex, int yIndex,
			Color initialHorizontalColor, Color initialVerticalColor) {
		this.northWest = new Point(northWestX, northWestY);
		this.northEast = new Point(southEastX, northWestY);
		this.southWest = new Point(northWestX, southEastY);
		this.southEast = new Point(southEastX, southEastY);
		this.xIndex = xIndex;
		this.yIndex = yIndex;
		this.initialHorizontalColor = initialHorizontalColor;
		this.initialVerticalColor = initialVerticalColor;
		this.derivedDivisions = new ArrayList<DivisionBlock>();
		this.levelOfRecursion = 0;
		initMondrian();
		initRelationColor();
		initManhattanBuilder();
	}

	public DivisionBlock(int northWestX, int northWestY, int southEastX, int southEastY, Color groundColor, int levelOfRecursion) {
		this.northWest = new Point(northWestX, northWestY);
		this.northEast = new Point(southEastX, northWestY);
		this.southWest = new Point(northWestX, southEastY);
		this.southEast = new Point(southEastX, southEastY);
		this.groundColor = groundColor;
		this.levelOfRecursion = levelOfRecursion;
		this.derivedDivisions = new ArrayList<DivisionBlock>();
		initMondrian();
		initRelationColor();
		initManhattanBuilder();
	}

	private void initManhattanBuilder() {
		this.manhattanRecurser = new ManhattanBuilder(this);
	}

	public String getMondrian() {
		return this.mondrian;
	}

	private void initMondrian() {
		// i discovered the reason
		// why he changed his name from Mondriaan to Mondrian
		// , INRANDOM is an anagram of MONDRIAN
		// //////
		// //////
		// //////
		/*
		 * at the moment of creation each block receives a shuffled version of
		 * the string "MONDRIAN" , this shuffled string is used within the
		 * recursion to see if a certain action should be performed or not
		 * letters are removed and sometimes added
		 */
		this.mondrian = RandomEngine.shuffleString(Mondrian.MONDRIAN);
	}

	public void removeMondrianLetter(String toRemove) {
		this.mondrian = this.mondrian.replaceFirst(toRemove, "");
	}

	public void addMondrianLetter(String toAdd) {
		this.mondrian += toAdd;
	}

	public List<DivisionBlock> getAllCreatedDivisionBlocks() {
		List<DivisionBlock> all = new ArrayList<DivisionBlock>();

		all.addAll(this.getDerivedRecursedDivisions());
		all.add(this);
		return all;
	}

	public void recurseDivisionBlock() {
		// a block completely outside of the losange
		// or at the end of the recurseCycle does not have to recurse
		if (this.getRelationToLosangeForRecursion() != RelationToLosangeForRecursion.NONE) {
			if (this.levelOfRecursion < this.getRelationToLosangeForRecursion().getRecursionIndex()) {
				this.levelOfRecursion++;
				// System.out.println("REC " + this.levelOfRecursion + " and "
				// +
				// this.getRelationToLosangeForRecursion().getRecursionIndex());

				this.manhattanRecurser.recurseDivisionBlock();

				/*
				 * if at the end of one recurse cycle the block has no derived
				 * blocks created then the block is looped through the cycle
				 * again, crossing fingers
				 */
				if (this.derivedDivisions.isEmpty()) {
					/*
					 * the above comment is not true anymore but time passed and
					 * it is true again
					 */
					this.manhattanRecurser.recurseDivisionBlock();
				}
			}
		}
	}

	private void initRelationColor() {
		this.distanceToCenter = DrawingMachine.calculateDistanceFromCenter(getCenter());
		this.relationToLosangeForRecursion = calculateRelationToLosange();
		this.correctGroundColor();
	}

	public List<DivisionBlock> getDerivedDivisions() {
		return derivedDivisions;
	}

	public List<DivisionBlock> getDerivedRecursedDivisions() {
		List<DivisionBlock> ret = new ArrayList<DivisionBlock>();
		this.recurseDivisionBlock();
		for (DivisionBlock db : this.derivedDivisions) {
			db.recurseDivisionBlock();
			ret.add(db);
			ret.addAll(db.getDerivedRecursedDivisions());
		}
		return ret;
	}

	public Integer getLevelOfRecursion() {
		return levelOfRecursion;
	}

	public void setLevelOfRecursion(Integer levelOfRecursion) {
		this.levelOfRecursion = levelOfRecursion;
	}

	public Color getInitialHorizontalColor() {
		return initialHorizontalColor;
	}

	public void setInitialHorizontalColor(Color initialHorizontalColor) {
		this.initialHorizontalColor = initialHorizontalColor;
	}

	public Color getInitialVerticalColor() {
		return initialVerticalColor;
	}

	public void setInitialVerticalColor(Color initialVerticalColor) {
		this.initialVerticalColor = initialVerticalColor;
	}

	public Color getGroundColor() {
		return groundColor;
	}

	public void setGroundColor(Color groundColor) {
		this.groundColor = groundColor;
	}

	public Integer getxIndex() {
		return xIndex;
	}

	public Integer getyIndex() {
		return yIndex;
	}

	public double getDistanceToCenter() {
		return distanceToCenter;
	}

	public RelationToLosangeForRecursion getRelationToLosangeForRecursion() {
		return relationToLosangeForRecursion;
	}

	public Point getNorthWest() {
		return northWest;
	}

	public Point getNorthEast() {
		return northEast;
	}

	public Point getSouthWest() {
		return southWest;
	}

	public Point getSouthEast() {
		return southEast;
	}

	public Point getCenter() {
		return new Point(getX() + getWidth() / 2, getY() + getHeight() / 2);
	}

	public int getX() {
		return getNorthWest().x;
	}

	public int getY() {
		return getNorthWest().y;
	}

	public int getWidth() {
		return getNorthEast().x - getNorthWest().x;
	}

	public int getHeight() {
		return getSouthWest().y - getNorthWest().y;
	}

	public VictoryRectangle createVictoryRectangle(Color color) {
		if (color != null) {
			this.groundColor = color;
		} else {
			this.groundColor = getGroundColorForRelation();
		}
		VictoryRectangle rect = new VictoryRectangle(this.getX(), this.getY(), this.getWidth(), this.getHeight(), this.groundColor,
				this.mondrian);
		return rect;
	}

	private void correctGroundColor() {
		// TODO in dire need of fixing
		if (this.relationToLosangeForRecursion.equals(RelationToLosangeForRecursion.NONE)) {
			this.groundColor = getGroundColorForRelation();
		}
	}

	public Color getGroundColorForRelation() {
		// TODO in dire need of fixing
		Color color = this.groundColor;
		RelationToLosangeForRecursion relation = this.getRelationToLosangeForRecursion();
		if (relation == RelationToLosangeForRecursion.NONE) {
			color = ColorEngine.getRandomGrey();
		} else {
			color = ColorEngine.getVariatedWhite();
		}
		if (this.groundColor != null && relation == RelationToLosangeForRecursion.NONE) {
			this.groundColor = color;
		}
		return color;
	}

	private boolean northEastInLosange() {
		return DrawingMachine.LOSANGE.contains(northEast);
	}

	private boolean northWestInLosange() {
		return DrawingMachine.LOSANGE.contains(northWest);
	}

	private boolean southEastInLosange() {
		return DrawingMachine.LOSANGE.contains(southEast);
	}

	private boolean southWestInLosange() {
		return DrawingMachine.LOSANGE.contains(southWest);
	}

	private RelationToLosangeForRecursion calculateRelationToLosange() {
		int pointsInLosange = 0;
		if (northEastInLosange()) {
			pointsInLosange++;
		}
		if (northWestInLosange()) {
			pointsInLosange++;
		}
		if (southEastInLosange()) {
			pointsInLosange++;
		}
		if (southWestInLosange()) {
			pointsInLosange++;
		}
		RelationToLosangeForRecursion relationToLosange = null;
		switch (pointsInLosange) {
		case 0:
			relationToLosange = RelationToLosangeForRecursion.NONE;
			break;
		case 1:
			relationToLosange = RelationToLosangeForRecursion.ONE_POINT_INSIDE;
			break;
		case 2:
			relationToLosange = RelationToLosangeForRecursion.TWO_POINTS_INSIDE;
			break;
		case 3:
			relationToLosange = RelationToLosangeForRecursion.THREE_POINTS_INSIDE;
			break;
		case 4:
			relationToLosange = RelationToLosangeForRecursion.COMPLETELY_INSIDE;
			break;
		}
		return relationToLosange;
	}

	@Override
	public int compareTo(DivisionBlock o) {
		return new Integer(this.getHeight() * this.getWidth()).compareTo(new Integer(o.getHeight() * o.getWidth()));
	}
}

class InitialPositionAndColor implements Comparable<InitialPositionAndColor> {
	private Integer position;
	private Color color;
	private int thickNess;

	public InitialPositionAndColor(int position, Color color, int thickNess) {
		this.position = position;
		this.color = color;
		this.thickNess = thickNess;
	}

	public int getThickNess() {
		return thickNess;
	}

	public Integer getPosition() {
		return position;
	}

	public Color getColor() {
		return color;
	}

	@Override
	public int compareTo(InitialPositionAndColor o) {
		return this.getPosition().compareTo(o.getPosition());
	}
}

class DrawingMachine {
	public static final int HORIZONTALS = Mondrian.MONDRIAN.length();
	public static final int VERTICALS = Mondrian.MONDRIAN.length();

	public static final int CANVAS_WIDTH = 1280;
	public static final int CANVAS_HEIGHT = 960;

	public static final int MIDDLE_X = CANVAS_WIDTH / 2;
	public static final int MIDDLE_Y = CANVAS_HEIGHT / 2;

	public static final int WIDTH_LOSANGE = MIDDLE_Y - 40;
	public static final int HORIZONTAL_VERTICAL_OFFSET = 50;

	public static final int EXTERNAL_LOSANGE = 30;

	public static final Point CENTER = new Point(MIDDLE_X, MIDDLE_Y);

	public static final int MINIMAL_DISTANCE = 40;

	private List<VictoryElement> drawingElements;

	private Map<Integer, List<DivisionBlock>> grid;
	public static final Polygon LOSANGE;

	private List<InitialPositionAndColor> xs;
	private List<InitialPositionAndColor> ys;

	static {
		int[] xsLosange = new int[] { CENTER.x, CENTER.x + WIDTH_LOSANGE, CENTER.x, CENTER.x - WIDTH_LOSANGE };
		int[] ysLosange = new int[] { CENTER.y - WIDTH_LOSANGE, CENTER.y, CENTER.y + WIDTH_LOSANGE, CENTER.y };
		LOSANGE = new Polygon(xsLosange, ysLosange, 4);
	}

	public DrawingMachine() {
		init();
		draw();
	}

	public static double calculateDistanceFromCenter(Point point) {
		double distance = Math.sqrt((MIDDLE_X - point.x) * (MIDDLE_X - point.x) + (MIDDLE_Y - point.y) * (MIDDLE_Y - point.y));
		return distance / 600;
	}

	private void init() {
		this.xs = new ArrayList<InitialPositionAndColor>();
		this.ys = new ArrayList<InitialPositionAndColor>();
		this.drawingElements = new ArrayList<VictoryElement>();
		this.grid = new HashMap<Integer, List<DivisionBlock>>();
	}

	private void draw() {
		createFirstStructure();
		createRecursions();
		createLosange();
	}

	public List<DivisionBlock> createBorders() {
		List<DivisionBlock> borders = new ArrayList<DivisionBlock>();
		// the following 'contaminates' the horizontal borders on left and right
		// extremes with rectangles
		// to make 'transition'
		for (List<DivisionBlock> list : this.grid.values()) {
			for (DivisionBlock block : list) {
				Integer xIndex = block.getxIndex();
				Integer yIndex = block.getyIndex();

				if (xIndex != null
						&& (xIndex == 0 || yIndex == 0 || yIndex == DrawingMachine.VERTICALS || xIndex == DrawingMachine.HORIZONTALS)
						&& RandomEngine.getPositiveInt(2) == 0) {
					// create border rectangles
					int width = RandomEngine.getPositiveInt(30) + 10;
					DivisionBlock newDivisionBlock = null;
					if (xIndex == 0) {
						newDivisionBlock = new DivisionBlock(block.getX() - width, block.getY() + RandomEngine.getPositiveInt(6),
								block.getX() + width, block.getY() + block.getHeight() - RandomEngine.getPositiveInt(6),
								ColorEngine.getVariatedWhite(), RelationToLosangeForRecursion.COMPLETELY_INSIDE.getRecursionIndex());
					} else if (yIndex == 0) {
					} else if (yIndex == DrawingMachine.VERTICALS) {
					} else if (xIndex == DrawingMachine.HORIZONTALS) {
						newDivisionBlock = new DivisionBlock(block.getX() + block.getWidth() - width, block.getY()
								+ RandomEngine.getPositiveInt(6), block.getX() + block.getWidth() + width, block.getY()
								+ block.getHeight() - RandomEngine.getPositiveInt(6), ColorEngine.getVariatedWhite(),
								RelationToLosangeForRecursion.NONE.getRecursionIndex());
					}
					if (newDivisionBlock != null) {
						borders.add(newDivisionBlock);
					}
				}
			}
		}
		return borders;
	}

	public List<DivisionBlock> splitHorizontals() {
		List<DivisionBlock> list = new ArrayList<DivisionBlock>();
		// ///////////////////////
		// divide 3 biggest horizontal rows into 2 parts each
		int yIndex = 1;
		List<DivisionBlock> verticals = this.getDivisionBlocksForDirectionAndIndex(Direction.VERTICAL, yIndex);

		Collections.sort(verticals, new Comparator<DivisionBlock>() {
			@Override
			public int compare(DivisionBlock o1, DivisionBlock o2) {
				return new Integer(o1.getHeight()).compareTo(new Integer(o2.getHeight()));
			}
		});
		Collections.reverse(verticals);
		// // we take three highest verticals
		verticals = verticals.subList(0, 3);
		for (DivisionBlock highest : verticals) {
			List<DivisionBlock> horizontals = this.getDivisionBlocksForDirectionAndIndex(Direction.HORIZONTAL, highest.getyIndex());

			for (DivisionBlock horizontal : horizontals) {
				if (LOSANGE.contains(horizontal.getCenter())) {
					// divide block horizontally in two
					int heightDivision = horizontal.getHeight() / 2;
					DivisionBlock upperHalf = new DivisionBlock(horizontal.getX(), horizontal.getY(), horizontal.getX()
							+ horizontal.getWidth(), horizontal.getY() + heightDivision, horizontal.getxIndex(),
							horizontal.getyIndex(), horizontal.getInitialHorizontalColor(), horizontal.getInitialVerticalColor());// ,
					// ColorEngine.getVariatedWhite());
					DivisionBlock lowerHalf = new DivisionBlock(horizontal.getX(), horizontal.getY() + heightDivision,
							horizontal.getX() + horizontal.getWidth(), horizontal.getY() + heightDivision * 2, horizontal.getxIndex(),
							horizontal.getyIndex(), horizontal.getInitialHorizontalColor(), horizontal.getInitialVerticalColor());// ,
					// ColorEngine.getVariatedWhite());
					upperHalf.setLevelOfRecursion(RelationToLosangeForRecursion.NONE.getRecursionIndex());
					lowerHalf.setLevelOfRecursion(RelationToLosangeForRecursion.NONE.getRecursionIndex());

					// they become children of the block they divided in 2
					horizontal.getDerivedDivisions().add(upperHalf);
					horizontal.getDerivedDivisions().add(lowerHalf);
					// exempt this divisionblock of recursion
					horizontal.setLevelOfRecursion(RelationToLosangeForRecursion.NONE.getRecursionIndex());
					// horizontal.setVisible(false);
					list.add(upperHalf);
					list.add(lowerHalf);
				}
			}
		}
		return list;
	}

	public List<DivisionBlock> splitVerticals() {
		List<DivisionBlock> list = new ArrayList<DivisionBlock>();
		// ///////////////////////
		// divide biggest vertical row into 2
		int xIndex = 1;
		List<DivisionBlock> horizontals = this.getDivisionBlocksForDirectionAndIndex(Direction.HORIZONTAL, xIndex);

		Collections.sort(horizontals, new Comparator<DivisionBlock>() {
			@Override
			public int compare(DivisionBlock o1, DivisionBlock o2) {
				return new Integer(o1.getWidth()).compareTo(new Integer(o2.getWidth()));
			}
		});
		Collections.reverse(horizontals);
		// // we take three highest verticals
		horizontals = horizontals.subList(0, 1);
		for (DivisionBlock widest : horizontals) {
			List<DivisionBlock> verticals = this.getDivisionBlocksForDirectionAndIndex(Direction.VERTICAL, widest.getxIndex());

			for (DivisionBlock vertical : verticals) {
				if (LOSANGE.contains(vertical.getCenter())) {
					// divide block vertically in two
					int widthDivision = vertical.getWidth() / 2;
					DivisionBlock leftHalf = new DivisionBlock(vertical.getX(), vertical.getY(), vertical.getX() + widthDivision,
							vertical.getY() + vertical.getHeight(), vertical.getxIndex(), vertical.getyIndex(),
							vertical.getInitialHorizontalColor(), vertical.getInitialVerticalColor());
					DivisionBlock rightHalf = new DivisionBlock(vertical.getX() + widthDivision, vertical.getY(), vertical.getX()
							+ vertical.getWidth(), vertical.getY() + vertical.getHeight(), vertical.getxIndex(), vertical.getyIndex(),
							vertical.getInitialHorizontalColor(), vertical.getInitialVerticalColor());
					leftHalf.setLevelOfRecursion(RelationToLosangeForRecursion.NONE.getRecursionIndex());
					rightHalf.setLevelOfRecursion(RelationToLosangeForRecursion.NONE.getRecursionIndex());

					// they become children of the block they divided in 2
					vertical.getDerivedDivisions().add(leftHalf);
					vertical.getDerivedDivisions().add(rightHalf);
					// exempt this divisionblock of recursion
					vertical.setLevelOfRecursion(RelationToLosangeForRecursion.NONE.getRecursionIndex());
					list.add(leftHalf);
					list.add(rightHalf);
				}
			}
		}
		return list;
	}

	public List<DivisionBlock> getDivisionBlocksForDirectionAndIndex(Direction direction, Integer index) {
		List<DivisionBlock> ret = new ArrayList<DivisionBlock>();
		if (direction.equals(Direction.VERTICAL)) {
			ret.addAll(this.grid.get(index));
		} else if (direction.equals(Direction.HORIZONTAL)) {
			for (List<DivisionBlock> verticals : grid.values()) {
				ret.add(verticals.get(index));
			}
		}
		return ret;
	}

	public List<DivisionBlock> deriveFromGrid() {
		List<DivisionBlock> list = new ArrayList<DivisionBlock>();
		/*
		 * the widest and highest of these rows and columns are each split in 2
		 * , to further granularize the grid
		 */
		list.addAll(splitHorizontals());
		list.addAll(splitVerticals());
		return list;
	}

	private void createRecursions() {
		List<DivisionBlock> all = new ArrayList<DivisionBlock>();
		List<DivisionBlock> fromGridAndDerivedFromGrid = new ArrayList<DivisionBlock>();
		for (List<DivisionBlock> divisionBlocksFromGrid : this.grid.values()) {
			fromGridAndDerivedFromGrid.addAll(divisionBlocksFromGrid);
		}

		fromGridAndDerivedFromGrid.addAll(deriveFromGrid());
		fromGridAndDerivedFromGrid.addAll(createBorders());

		for (DivisionBlock divisionBlock : fromGridAndDerivedFromGrid) {
			List<DivisionBlock> finalDivisions = divisionBlock.getAllCreatedDivisionBlocks();
			all.addAll(finalDivisions);
		}
		Collections.sort(all);
		// TODO fix comparator
		Collections.reverse(all);
//		System.out.println("ALL " + all.size());
		int left = 70;
		int right = DrawingMachine.CANVAS_WIDTH - 35 - left;
		for (DivisionBlock recursed : all) {
			VictoryRectangle recursedRectangle = recursed.createVictoryRectangle(recursed.getGroundColor());
			// recursedRectangle.setWriteText(LOSANGE.contains(recursed.getCenter()));
			// System.out.println(recursed.getMondrian());

			/*
			 * at the end of all recursions the blocks are drawn and the strings
			 * of all blocks are written left and right of the blocks
			 */
			getDrawingElements().add(recursedRectangle);
			int x = RandomEngine.getBoolean() ? left : right;
			VictoryText text = new VictoryText(recursed.getMondrian(), new Point(x,
					RandomEngine.getPositiveInt(DrawingMachine.CANVAS_HEIGHT)), ColorEngine.getFromWhiteToBlack());
			getDrawingElements().add(text);
			createEllipse(recursed);
		}
	}

	private void createEllipse(DivisionBlock divisionBlock) {
		Color color = Color.BLACK;

		double diameter = 8.5d - new Double(divisionBlock.getLevelOfRecursion())
				- new Double(divisionBlock.getRelationToLosangeForRecursion().getRecursionIndex())
				+ divisionBlock.getDistanceToCenter();
		int diameterAsInt = new Double(diameter / 2).intValue();

		VictoryEllipse victoryEllipse = new VictoryEllipse(new Point(divisionBlock.getCenter().x - diameterAsInt,
				divisionBlock.getCenter().y - diameterAsInt), diameter, color);
		getDrawingElements().add(victoryEllipse);
	}

	public void redraw() {
		init();
		draw();
	}

	public Map<Integer, List<DivisionBlock>> getGrid() {
		return grid;
	}

	private void createFirstStructure() {
		/*
		 * a first structure is built of 8 verticals and 8 horizontals
		 */
		List<VictoryRectangle> firstStructure = new ArrayList<VictoryRectangle>();

		List<VictoryRectangle> verticals = createFirstVerticals();
		List<VictoryRectangle> horizontals = createFirstHorizontals();

		Collections.sort(this.xs);
		Collections.sort(this.ys);

		initDivisionBlocks(this.xs, this.ys);

		firstStructure.addAll(verticals);
		firstStructure.addAll(horizontals);
		// weave the structure lines
		Collections.shuffle(firstStructure);
		getDrawingElements().addAll(firstStructure);

	}

	private void initDivisionBlocks(List<InitialPositionAndColor> xs, List<InitialPositionAndColor> ys) {
		/*
		 * the intersections of these lines define a grid
		 */
		/*
		 * the grid is made up of blocks ( manhattanlingo ) , these 9 by 9
		 * blocks define the division of further drawing
		 */
		for (int i = 0; i < xs.size(); i++) {
			InitialPositionAndColor northX = xs.get(i);
			for (int j = 0; j < ys.size(); j++) {
				InitialPositionAndColor northY = ys.get(j);
				if (i + 1 < xs.size() && j + 1 < ys.size()) {
					InitialPositionAndColor southX = xs.get(i + 1);
					InitialPositionAndColor southY = ys.get(j + 1);

					int northXPosition = northX.getPosition();
					int northYPosition = northY.getPosition();
					int southXPosition = southX.getPosition();
					int southYPosition = southY.getPosition();
					int showBorder = RandomEngine.getPositiveInt(12);
					// reveal possibly some of the underlying first structure
					if (showBorder == 0) {
						northXPosition += northX.getThickNess();
					} else if (showBorder == 1) {
						northYPosition += northY.getThickNess();
					} else if (showBorder == 2) {
						southXPosition += southX.getThickNess();
					} else if (showBorder == 3) {
						southYPosition += southY.getThickNess();
					}

					DivisionBlock divisionBlock = new DivisionBlock(northXPosition, northYPosition, southXPosition, southYPosition, i,
							j, northY.getColor(), northX.getColor());

					if (this.grid.get(i) != null) {
						this.grid.get(i).add(divisionBlock);
					} else {
						List<DivisionBlock> blocks = new ArrayList<DivisionBlock>();
						blocks.add(divisionBlock);
						this.grid.put(i, blocks);
					}
				}
			}
		}
	}

	private List<VictoryRectangle> createFirstHorizontals() {
		List<VictoryRectangle> horizontals = new ArrayList<VictoryRectangle>();

		int up = CENTER.y - WIDTH_LOSANGE + HORIZONTAL_VERTICAL_OFFSET;
		int down = CENTER.y + WIDTH_LOSANGE - HORIZONTAL_VERTICAL_OFFSET;
		while (horizontals.size() < HORIZONTALS) {

			int y = RandomEngine.getPositiveInt(down - up) + up;
			boolean weAdd = true;
			for (VictoryRectangle vr : horizontals) {
				if (vr.isInNeighborhoodY(y)) {
					weAdd = false;
					break;
				}
			}
			if (weAdd) {
				int heightRectangle = RandomEngine.getPositiveInt(8) + 6;

				if (horizontals.size() == 0) {
					this.ys.add(new InitialPositionAndColor(CENTER.y - WIDTH_LOSANGE - EXTERNAL_LOSANGE, null, heightRectangle)); // north
																																	// limit
				}
				Color primaryColor = ColorEngine.getPrimaryColor(true);
				int distanceToKeepFromHorizontalBorder = RandomEngine.getPositiveInt(30);
				VictoryRectangle rectangle = new VictoryRectangle(CENTER.x - MIDDLE_X + distanceToKeepFromHorizontalBorder, y,
						CANVAS_WIDTH - distanceToKeepFromHorizontalBorder * 2, heightRectangle, primaryColor, "");
				this.ys.add(new InitialPositionAndColor(y, primaryColor, heightRectangle));
				horizontals.add(rectangle);

				if (horizontals.size() == HORIZONTALS) {
					this.ys.add(new InitialPositionAndColor(CENTER.y + WIDTH_LOSANGE + EXTERNAL_LOSANGE, null, heightRectangle)); // south
																																	// limit
				}
			}
		}
		return horizontals;
	}

	private List<VictoryRectangle> createFirstVerticals() {
		List<VictoryRectangle> verticals = new ArrayList<VictoryRectangle>();

		int left = CENTER.x - WIDTH_LOSANGE + HORIZONTAL_VERTICAL_OFFSET;
		int right = CENTER.x + WIDTH_LOSANGE - HORIZONTAL_VERTICAL_OFFSET;
		while (verticals.size() < VERTICALS) {

			int x = RandomEngine.getPositiveInt(right - left) + left;
			boolean weAdd = true;
			for (VictoryRectangle vr : verticals) {
				if (vr.isInNeighborhoodX(x)) {
					weAdd = false;
					break;
				}
			}
			if (weAdd) {
				int widthRectangle = RandomEngine.getPositiveInt(8) + 6;

				if (verticals.size() == 0) {
					this.xs.add(new InitialPositionAndColor(CENTER.x - WIDTH_LOSANGE - EXTERNAL_LOSANGE, null, widthRectangle)); // left
																																	// limit
				}

				Color primaryColor = ColorEngine.getPrimaryColor(true);
				VictoryRectangle rectangle = new VictoryRectangle(x, CENTER.y - MIDDLE_Y, widthRectangle, CANVAS_HEIGHT, primaryColor,
						"");
				this.xs.add(new InitialPositionAndColor(x, primaryColor, widthRectangle));
				verticals.add(rectangle);

				if (verticals.size() == VERTICALS) {
					this.xs.add(new InitialPositionAndColor(CENTER.x + WIDTH_LOSANGE + EXTERNAL_LOSANGE, null, widthRectangle)); // right
																																	// limit
				}
			}
		}
		return verticals;
	}

	private void createLosange() {
		getDrawingElements().add(new VictoryPolygon(LOSANGE));
	}

	public List<VictoryElement> getDrawingElements() {
		return drawingElements;
	}
}

interface VictoryElement {
	void draw(Graphics g);
}

class VictoryText implements VictoryElement {
	private String mondrian;
	private Point point;
	private Color color;

	public VictoryText(String mondrian, Point point, Color color) {
		this.mondrian = mondrian;
		this.point = point;
		this.color = color;
	}

	@Override
	public void draw(Graphics g) {
		g.setColor(color);
		Font font = g.getFont();
		g.setFont(font.deriveFont(8f));
		g.drawString(this.mondrian, this.point.x, this.point.y);
	}
}

class VictoryRectangle implements VictoryElement, Comparable<VictoryRectangle> {
	private Rectangle rectangle;
	private Color color;
	private String mondrian;
	private boolean writeText;

	public VictoryRectangle(int x, int y, int width, int height, Color color, String mondrian) {
		this.rectangle = new Rectangle(x, y, width, height);
		this.color = color;
		this.mondrian = mondrian;
	}

	public boolean isWriteText() {
		return writeText;
	}

	public void setWriteText(boolean writeText) {
		this.writeText = writeText;
	}

	public String getMondrian() {
		return mondrian;
	}

	public boolean isInNeighborhoodX(int x) {
		if (Math.abs(this.rectangle.x - x) < DrawingMachine.MINIMAL_DISTANCE) {
			return true;
		}
		return false;
	}

	public boolean isInNeighborhoodY(int y) {
		if (Math.abs(this.rectangle.y - y) < DrawingMachine.MINIMAL_DISTANCE) {
			return true;
		}
		return false;
	}

	public int getX() {
		return this.rectangle.x;
	}

	public int getY() {
		return this.rectangle.y;
	}

	@Override
	public void draw(Graphics g) {
		g.setColor(this.color);
		g.drawRect(this.rectangle.x, this.rectangle.y, this.rectangle.width, this.rectangle.height);
		g.fillRect(this.rectangle.x, this.rectangle.y, this.rectangle.width, this.rectangle.height);
		if (this.isWriteText()) {
			g.setColor(Color.BLACK);
			Font font = g.getFont();
			g.setFont(font.deriveFont(8f));
			g.drawString(this.mondrian, this.rectangle.x + this.rectangle.width / 4, this.rectangle.y + this.rectangle.height / 2);
		}
	}

	@Override
	public int compareTo(VictoryRectangle o) {
		if (getY() == 0) {
			return new Integer(getX()).compareTo(o.getX());
		} else {
			return new Integer(getX()).compareTo(o.getY());
		}
	}
}

class VictoryPolygon implements VictoryElement {
	private Polygon polygon;
	private Color color;

	public VictoryPolygon(Polygon polygon) {
		this.polygon = polygon;
		this.color = Color.BLACK;
	}

	public VictoryPolygon(Polygon polygon, Color color) {
		this.polygon = polygon;
		this.color = color;
	}

	@Override
	public void draw(Graphics g) {
		Graphics2D g2 = (Graphics2D) g;
		g.setColor(this.color);
		g2.setStroke(new BasicStroke(3.6f));
		g.drawPolygon(this.polygon);
	}
}

class VictoryEllipse implements VictoryElement {
	private int x;
	private int y;
	private double diameter;
	private Color color;

	public VictoryEllipse(Point point, double diameter, Color color) {
		this.x = point.x;
		this.y = point.y;
		this.diameter = diameter;
		this.color = color;
	}

	@Override
	public void draw(Graphics g) {
		Graphics2D g2d = (Graphics2D) g;
		g2d.setColor(this.color);
		Ellipse2D.Double circle = new Ellipse2D.Double(x, y, diameter, diameter);
		g2d.fill(circle);
	}
}

class VBWPanel extends JPanel {
	private static final long serialVersionUID = 1L;
	private DrawingMachine drawingMachine;

	public VBWPanel() {
		super();
		this.drawingMachine = new DrawingMachine();
		setSize(DrawingMachine.CANVAS_WIDTH, DrawingMachine.CANVAS_HEIGHT);
		setBackground(Color.WHITE);
		MouseAdapter mouseAdapter = new MouseAdapter() {
			@Override
			public void mousePressed(MouseEvent e) {
				getDrawingMachine().redraw();
				repaint();
			}
		};

		addMouseListener(mouseAdapter);
	}

	@Override
	public void paintComponent(Graphics g) {
		super.paintComponent(g);
		Graphics2D g2 = (Graphics2D) g;
		g2.setRenderingHint(RenderingHints.KEY_ANTIALIASING, RenderingHints.VALUE_ANTIALIAS_ON);
		for (VictoryElement victoryElement : this.drawingMachine.getDrawingElements()) {
			victoryElement.draw(g);
		}
		print(g, "INTERLICHTSPIELHAUS", new Point(1140, 935), 10f, ColorEngine.PRINTCOLOR);
		print(g, getDateStringed() + ".intrah", new Point(1140, 950), 10f, ColorEngine.PRINTCOLOR);
		/*
		 * a lot of drawn elements remain invisible , lost in between the layers
		 * of overlapping blocks, victory buggy wuggy ?
		 */
	}

	private String getDateStringed() {
		SimpleDateFormat formatter = new SimpleDateFormat("dd-MM-yyyy-HHmmss");
		return formatter.format(new Date());
	}

	private void print(Graphics g, String text, Point point, float fontSize, Color color) {
		g.setColor(color);
		Font font = g.getFont();
		g.setFont(font.deriveFont(fontSize));
		g.drawString(text, point.x, point.y);
	}

	public DrawingMachine getDrawingMachine() {
		return drawingMachine;
	}
}

class ManhattanBuilder {
	private DivisionBlock divisionBlock;
	private boolean createStrip;
	private boolean split;
	private boolean shift;
	private boolean extend;
	private boolean updateGroundColor;
	private boolean drawInMiddleRectangle;
	private boolean createFullStrip;
	private boolean delete;
	private boolean fillRectangle;

	private static final int STRIPSIZE = 12;
	private static final int FULLSTRIPSIZE = 18;

	public ManhattanBuilder(DivisionBlock divisionBlock) {
		this.divisionBlock = divisionBlock;
		/*
		 * action switches
		 */
		this.createStrip = true;
		this.split = true;
		this.shift = true;
		this.updateGroundColor = true;
		this.drawInMiddleRectangle = true;
		this.createFullStrip = true;
		this.extend = true;
		this.delete = true;
		this.fillRectangle = true;
	}

	public void recurseDivisionBlock() {
		// TODO lettering
		/*
		 * the different actions potentially performed on a block during a
		 * recursive cycle are: - split the block horizontally or vertically -
		 * shift blocks horizontally or vertically - creating a strip of small
		 * blocks within and/or outside the boundaries of the block being
		 * recursed - change the surface color of the block - draw a rectangle
		 * in the middle of the block - delete a derived block
		 * 
		 * these actions are the most visible ones in Mondrian's Victory Boogie
		 * Woogie , things are continuously being shifted, split, rearranged,
		 * recolored, overwritten, extended .. always repeating and never
		 * repeating itself
		 */
		String mondrianLetter = Mondrian.getRandomMondrianLetter();
		/*
		 * at the moment of creation each block receives a shuffled version of
		 * the string "MONDRIAN" , this shuffled string is used within the
		 * recursion to see if a certain action should be performed or not
		 * letters are removed and sometimes added
		 */
		if (this.divisionBlock.getMondrian().contains(mondrianLetter) && this.divisionBlock.getDerivedDivisions().isEmpty()) {
			split();
			shift();
			createStrip();
			updateGroundColor();
			drawInMiddleRectangle();
			this.divisionBlock.removeMondrianLetter(mondrianLetter);
		}
		if (this.divisionBlock.getLevelOfRecursion() == RelationToLosangeForRecursion.ONE_POINT_INSIDE.getRecursionIndex()) {
			mondrianLetter = Mondrian.getRandomMondrianLetter();
			String deleteLetter = Mondrian.getRandomMondrianLetter();
			if (this.divisionBlock.getMondrian().startsWith(mondrianLetter)) {
				if (!this.divisionBlock.getMondrian().contains(deleteLetter)) {
					delete();
					this.divisionBlock.addMondrianLetter(deleteLetter);
				}
				this.divisionBlock.removeMondrianLetter(mondrianLetter);
			}
		} else if (this.divisionBlock.getLevelOfRecursion() == RelationToLosangeForRecursion.TWO_POINTS_INSIDE.getRecursionIndex()) {
			mondrianLetter = Mondrian.getRandomMondrianLetter();
			if (this.divisionBlock.getMondrian().startsWith(mondrianLetter)) {
				fillRectangle();
				this.divisionBlock.removeMondrianLetter(mondrianLetter);
			}
		} else if (this.divisionBlock.getLevelOfRecursion() == RelationToLosangeForRecursion.THREE_POINTS_INSIDE.getRecursionIndex()) {
			extend();
		} else if (this.divisionBlock.getLevelOfRecursion() == RelationToLosangeForRecursion.COMPLETELY_INSIDE.getRecursionIndex()) {
			// TODO
		}

		mondrianLetter = Mondrian.getRandomMondrianLetter();
		if (this.divisionBlock.getMondrian().startsWith(mondrianLetter)) {
			createFullStrip();
			this.divisionBlock.removeMondrianLetter(mondrianLetter);
		}
	}

	/*
	 * 
	 * during a cycle of recursion of a block , derived blocks are created which
	 * will in turn also be recursed
	 */
	private void fillRectangle() {
		if (this.fillRectangle) {
			if (this.divisionBlock.getWidth() > 60 || this.divisionBlock.getHeight() > 60) {
				int height = RandomEngine.getBooleanInt(4) ? STRIPSIZE : RandomEngine.getPositiveInt(2) + 1;

				Color alternateColor = ColorEngine.getExtendedPrimaryColors(true);
				int xs = divisionBlock.getWidth() / STRIPSIZE;
				int ys = divisionBlock.getHeight() / STRIPSIZE;
				int x = this.divisionBlock.getX();
				int y = this.divisionBlock.getY();
				int counter = 0;
				for (int i = 0; i < xs; i++) {
					x = this.divisionBlock.getX();
					for (int j = 0; j < ys; j++) {
						Color color = counter % 2 == 0 ? ColorEngine.addLittleColorVariation(alternateColor) : ColorEngine
								.getVictoryColor(true);
						DivisionBlock newDivision = new DivisionBlock(x, y, x + STRIPSIZE, y + height, color,
								this.divisionBlock.getLevelOfRecursion());
						this.divisionBlock.getDerivedDivisions().add(newDivision);
						x += STRIPSIZE;
						counter++;
					}
					y += STRIPSIZE;
				}
			}
		}
	}

	private void extend() {
		if (this.extend) {
			// TODO
		}
	}

	private void delete() {
		if (this.delete) {
			if (!this.divisionBlock.getDerivedDivisions().isEmpty()) {
				int lastElement = this.divisionBlock.getDerivedDivisions().size() - 1;
				this.divisionBlock.getDerivedDivisions().remove(lastElement);
			}
		}
	}

	private void createFullStrip() {
		// TODO determining positions
		if (this.createFullStrip) {
			if (this.divisionBlock.getxIndex() != null && this.divisionBlock.getyIndex() != null) {
				int variation = getVariationOn(STRIPSIZE);
				int fullVariation = getVariationOn(FULLSTRIPSIZE);
				if (!RandomEngine.getBooleanInt(4)) {
					// horizontal
					int xRight = RandomEngine.getPositiveInt(460) + 590;
					int xTravel = this.divisionBlock.getX() - RandomEngine.getPositiveInt(96) - 25;
					while (xTravel < xRight) {
						DivisionBlock newDivision = new DivisionBlock(xTravel, this.divisionBlock.getY()
								+ this.divisionBlock.getHeight() - variation, xTravel + fullVariation, this.divisionBlock.getY()
								+ this.divisionBlock.getHeight(), ColorEngine.getVictoryColorWithoutGrey(true),
								this.divisionBlock.getLevelOfRecursion());
						this.divisionBlock.getDerivedDivisions().add(newDivision);
						xTravel += fullVariation;
					}

				} else {
					int yTop = RandomEngine.getPositiveInt(410) + 510;
					int yTravel = this.divisionBlock.getY() - RandomEngine.getPositiveInt(96) - 35;
					while (yTravel < yTop) {
						DivisionBlock newDivision = new DivisionBlock(this.divisionBlock.getX() + this.divisionBlock.getWidth()
								- variation, yTravel, this.divisionBlock.getX() + this.divisionBlock.getWidth(), yTravel
								+ fullVariation, ColorEngine.getVictoryColorWithoutGrey(true),
								this.divisionBlock.getLevelOfRecursion());
						this.divisionBlock.getDerivedDivisions().add(newDivision);
						yTravel += fullVariation;
					}
				}
			}
		}
	}

	private void split() {
		if (this.split) {
			// split rectangle
			if (RandomEngine.getBoolean()) {
				// split horizontally
				int heightToSplit = divisionBlock.getHeight() / 2;
				DivisionBlock first = new DivisionBlock(divisionBlock.getX() + STRIPSIZE, divisionBlock.getY(), divisionBlock.getX()
						+ divisionBlock.getWidth() - STRIPSIZE, divisionBlock.getY() + heightToSplit,
						ColorEngine.getVictoryColor(true), divisionBlock.getLevelOfRecursion());
				divisionBlock.getDerivedDivisions().add(first);

				DivisionBlock second = new DivisionBlock(divisionBlock.getX() + STRIPSIZE, divisionBlock.getY() + heightToSplit,
						divisionBlock.getX() + divisionBlock.getWidth() - STRIPSIZE, divisionBlock.getY() + divisionBlock.getHeight(),
						ColorEngine.getVictoryColor(true), divisionBlock.getLevelOfRecursion());
				divisionBlock.getDerivedDivisions().add(second);

			} else {
				// split vertically
				int widthToSplit = divisionBlock.getWidth() / 2;

				DivisionBlock first = new DivisionBlock(divisionBlock.getX(), divisionBlock.getY() + STRIPSIZE, divisionBlock.getX()
						+ widthToSplit, divisionBlock.getY() + divisionBlock.getHeight() - STRIPSIZE,
						ColorEngine.getVictoryColor(true), divisionBlock.getLevelOfRecursion());
				divisionBlock.getDerivedDivisions().add(first);
				DivisionBlock second = new DivisionBlock(divisionBlock.getX() + widthToSplit, divisionBlock.getY() + STRIPSIZE,
						divisionBlock.getX() + divisionBlock.getWidth(), divisionBlock.getY() + divisionBlock.getHeight() - STRIPSIZE,
						ColorEngine.getVictoryColorWithoutGrey(true), divisionBlock.getLevelOfRecursion());
				divisionBlock.getDerivedDivisions().add(second);
			}
		}

	}

	private void shift() {
		if (this.shift) {
			if (divisionBlock.getDerivedDivisions().isEmpty()) {
				if (RandomEngine.getBoolean()) {
					// shift height
					int extendHeight = RandomEngine.getNaturalInt(30);
					DivisionBlock newDivision = new DivisionBlock(divisionBlock.getX() + extendHeight, divisionBlock.getY(),
							divisionBlock.getX() + extendHeight + divisionBlock.getWidth(), divisionBlock.getY()
									+ divisionBlock.getHeight(), divisionBlock.getGroundColor(), divisionBlock.getLevelOfRecursion());
					divisionBlock.getDerivedDivisions().add(newDivision);
				} else {
					// shift width
					int extendWidth = RandomEngine.getNaturalInt(30);
					DivisionBlock newDivision = new DivisionBlock(divisionBlock.getX(), divisionBlock.getY() + extendWidth,
							divisionBlock.getX() + divisionBlock.getWidth(), divisionBlock.getY() + divisionBlock.getHeight()
									+ extendWidth, divisionBlock.getGroundColor(), divisionBlock.getLevelOfRecursion());
					divisionBlock.getDerivedDivisions().add(newDivision);
				}
			}
		}
	}

	private void updateGroundColor() {
		if (updateGroundColor) {
			String mondrianLetter = Mondrian.getRandomMondrianLetter();
			if (this.divisionBlock.getMondrian().contains(mondrianLetter)) {
				Color color = null;
				if (RandomEngine.getBooleanInt(6)) {
					color = ColorEngine.getVariatedWhite();
				} else {
					color = ColorEngine.getVictoryColor(true);
				}
				divisionBlock.setGroundColor(color);
				this.divisionBlock.removeMondrianLetter(mondrianLetter);
			}
		}
	}

	private void drawInMiddleRectangle() {
		if (this.drawInMiddleRectangle) {
			// draw rectangle in the middle of divisionBlock
			DivisionBlock newDivision = new DivisionBlock(divisionBlock.getCenter().x - divisionBlock.getWidth() / 4,
					divisionBlock.getCenter().y - divisionBlock.getHeight() / 4, divisionBlock.getCenter().x
							+ divisionBlock.getHeight() / 4, divisionBlock.getCenter().y + divisionBlock.getHeight() / 4,
					ColorEngine.getVictoryColorWithoutGrey(true), divisionBlock.getLevelOfRecursion());
			divisionBlock.getDerivedDivisions().add(newDivision);
		}
	}

	private void createStrip() {
		// TODO determine positions
		if (this.createStrip) {
			if (this.divisionBlock.getDerivedDivisions().size() <= 1) {
				List<DivisionBlock> strip = new ArrayList<DivisionBlock>();

				if (RandomEngine.getBoolean()) {
					// create border to the top horizontally
					strip.addAll(createDivisionBlocksStripFrom(divisionBlock, Direction.HORIZONTAL, new Point(divisionBlock.getX(),
							divisionBlock.getY()), new Point(divisionBlock.getX() + divisionBlock.getWidth(), divisionBlock.getY())));
				} else {
					// create border to the left vertically
					strip.addAll(createDivisionBlocksStripFrom(divisionBlock, Direction.VERTICAL, new Point(divisionBlock.getX(),
							divisionBlock.getY()), new Point(divisionBlock.getX(), divisionBlock.getY() + divisionBlock.getHeight())));
				}
				// TODO bottom and right

				divisionBlock.getDerivedDivisions().addAll(strip);
			}
		}
	}

	private int getVariationOn(int toBeVariated) {
		return toBeVariated + RandomEngine.getNaturalInt(2);
	}

	private List<DivisionBlock> createDivisionBlocksStripFrom(DivisionBlock divisionBlock, Direction direction, Point start, Point end) {
		List<DivisionBlock> strip = new ArrayList<DivisionBlock>();
		int startX = start.x;
		int endX = end.x;
		int startY = start.y;
		int endY = end.y;
		int variation = getVariationOn(STRIPSIZE);
		Color firstColor = ColorEngine.getVictoryColor(true);
		int counter = 0;
		if (Direction.HORIZONTAL.equals(direction)) {
			while (startX < endX) {
				DivisionBlock newDivision = new DivisionBlock(startX, startY, startX + variation, endY + variation,
						counter % 1 == 0 ? ColorEngine.getVictoryColorWithoutGrey(true) : firstColor,
						divisionBlock.getLevelOfRecursion());
				startX += variation;
				strip.add(newDivision);
				counter++;
			}
		} else if (Direction.VERTICAL.equals(direction)) {
			while (startY < endY) {
				DivisionBlock newDivision = new DivisionBlock(startX, startY, startX + variation, endY + variation,
						counter % 1 == 0 ? ColorEngine.getVictoryColorWithoutGrey(true) : firstColor,
						divisionBlock.getLevelOfRecursion());
				startY += variation;
				strip.add(newDivision);
				counter++;
			}
		}

		return strip;
	}

	private List<Integer> divideDistance(int amountOfDivisions, int toDivide) {
		List<Integer> ret = new ArrayList<Integer>();
		for (int i = 0; i < amountOfDivisions; i++) {
			ret.add(RandomEngine.getPositiveInt(toDivide));
		}
		Collections.sort(ret);
		return ret;
	}
}
